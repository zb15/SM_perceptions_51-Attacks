# -*- coding: utf-8 -*-
"""SM_Perceptions_51%_attacks.ipynb

Automatically generated by Colab.

# **User Perceptions of Cryptocurrency Attacks**

This notebook accompany our research on 51% attacks on Proof-of-Work (PoW) cryptocurrencies.

If you use it, please cite


---


...

url: https://github.com/zb15/SM_perceptions_51-Attacks

---

# **Datasets**

## **Input**
"""

import pandas as pd
MyData = pd.read_csv('bitcoin sv2021-08-02.csv')

myName = "Bitcoin SV 2-9 August 2021"
myUrl = "bitcoin_sv_02_08_2021"

"""## ***Whole dataset***

### **Cleaning** and **joining** the datasets
"""

import re
# Operate the data cleaning process on dataframe directly

# Make sure the column 'content' is of string type
MyData['content'] = MyData['content'].apply(str)
#Remove url links
MyData['clean_content'] = MyData['content'].str.replace(r"https?:\/\/\S*", "")
#place hastags to a new column before removing them
MyData['hashtag'] = MyData['content'].apply(lambda x: re.findall(r'\B#\w*[a-zA-Z]+\w*', x))
#place $ cashtags to a new column before removing them
MyData['cashtag'] = MyData['content'].apply(lambda x: re.findall(r'(?i)\$\w+', x))
#place @ mentions to a new column before removing them
MyData['mentions'] = MyData['content'].apply(lambda x: re.findall(r'\B@\w*[a-zA-Z]+\w*', x))
#Remove cashtags and mentions from clean content
MyData['clean_content'] = MyData['clean_content'].str.replace(r"(?i)\$\w+","")
MyData['clean_content'] = MyData['clean_content'].str.replace(r"\B@\w*[a-zA-Z]+\w*","")
# Remove special characters
MyData['clean_content'] = MyData['clean_content'].str.replace("[^a-zA-Z']"," ",regex=True)
# Remove leading and trailing whitespaces
MyData['clean_content'] = MyData['clean_content'].str.strip()
#convert all characters to lower case
MyData['clean_content'] = MyData['clean_content'].str.lower()

MyData.head()

# drop rows which have same clean_content
# and user and keep last (first appearance in time) entry
MyData = MyData.drop_duplicates(
  subset = ['clean_content', 'user'],
  keep = 'last').reset_index(drop = True)

MyData.describe()

#removing all non english tweets
MyData_en = MyData.drop(MyData[MyData["lang"]!='en'].index)

"""### Get the **sentiments**"""

# Get a bunch of tools from nltk
import re

import nltk
nltk.download('punkt')
nltk.download('stopwords')
from nltk import word_tokenize
from nltk.probability import FreqDist
from nltk.corpus import stopwords

# Get English stopwords
en_stopwords = set(stopwords.words('english'))

# Import the library for sentiment analysis

nltk.download('vader_lexicon')
from nltk.sentiment.vader import SentimentIntensityAnalyzer
sia = SentimentIntensityAnalyzer()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Define some functions for convenience

def getSentScore(text):
  myScore = sia.polarity_scores(text)['compound']
  return(myScore)

# Generate a new column to store the compound scores

MyData_en['sentiment_score'] = MyData_en.apply(lambda x: getSentScore(x['clean_content']), axis=1)

# Define some functions for convenience

def getSentCat(text):
  myScore = sia.polarity_scores(text)['compound']
  if myScore > 0:
    myCat = 'positive'
  elif myScore < 0:
    myCat = 'negative'
  else:
    myCat = 'neutral'
  return(myCat)

# Generate a new column to store the sentiment categories classified

MyData_en['sentiment_cat'] = MyData_en.apply(lambda x: getSentCat(x['clean_content']), axis=1)

pip install text2emotion

!pip install emoji==1.7.0

import text2emotion as te
#import nltk
nltk.download('omw-1.4')

# Define some functions for convenience

def getSentEmotions(text):
  myScores1 = te.get_emotion(text)
  return(myScores1)

# Generate a new column to store the compound scores
#generate a list to store the scores for the 5 emotions

MyData_en['sentiment_emotions'] = MyData_en.apply(lambda x: getSentEmotions(x['clean_content']), axis=1)

MyData_en['sentiment_emotions'] = MyData_en['sentiment_emotions'].apply(str)
#put the emotion scores in separate columns
MyData_en[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']] = MyData_en['sentiment_emotions'].str.split(',', 5, expand=True)

#keep only the scores for the emotions
MyData_en['Happy'] = MyData_en['Happy'].str[9:]
MyData_en['Happy'] = MyData_en['Happy'].astype(float, errors = 'raise')

MyData_en['Angry'] = MyData_en['Angry'].str[9:]
MyData_en['Angry'] = MyData_en['Angry'].astype(float, errors = 'raise')

MyData_en['Surprise'] = MyData_en['Surprise'].str[12:]
MyData_en['Surprise'] = MyData_en['Surprise'].astype(float, errors = 'raise')

MyData_en['Sad'] = MyData_en['Sad'].str[7:]
MyData_en['Sad'] = MyData_en['Sad'].astype(float, errors = 'raise')

MyData_en['Fear'] = MyData_en['Fear'].str[8:-1]
MyData_en['Fear'] = MyData_en['Fear'].astype(float, errors = 'raise')

MyData_en.head()

#MyData_en.to_csv('MyData_en_whole_'+myUrl+'.csv')

"""### Get the **statistics**"""

MyData_en[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']].describe()

MyData_en[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']].value_counts()

#melt data frame into long format
df_melted = pd.melt(MyData_en[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']])

#view first 10 rows of melted data frame
#df_melted.head(10)

import matplotlib.pyplot as plt
import seaborn as sns

#create seaborn boxplots by group
sns.boxplot(x='variable', y='value', data=df_melted, palette=["green", "red", "gold", "blue", "black"]).set(title='Emotion sentiments: %s (whole dataset)' % myName)

#modify axis labels
plt.xlabel('')
plt.ylabel('')

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("emotion_sentiments_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

MyData_en[['sentiment_cat']].value_counts()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(8,8),
                     sharey=True
                     )

sns.countplot(x="sentiment_cat",
            data=MyData_en,
            order=['negative', 'neutral', 'positive'], # specify the ordering
            palette=["red", "orange", "green"]
            #palette="flare",
            )

ax.set_title('Total sentiments: %s (whole dataset)' % myName,size=24)
ax.set_xlabel('')

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("sentiments_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""### **Timeline** of tweets per day"""

import datetime
MyData_en["date_time"] = MyData_en["date"].astype('datetime64[ns]')
MyData_en["date_time"] = MyData_en.date_time.dt.to_pydatetime()

#to have only dates without time
MyData_en["only_date"] = [d.date() for d in MyData_en["date_time"]]

MyData_en.tail()

MyData_en.to_csv("Dataset_"+myUrl+".csv")

neg = MyData_en[MyData_en['sentiment_cat']=='negative']
neg = neg.groupby(['only_date'],as_index=False).count()

pos = MyData_en[MyData_en['sentiment_cat']=='positive']
pos = pos.groupby(['only_date'],as_index=False).count()

neu = MyData_en[MyData_en['sentiment_cat']=='neutral']
neu = neu.groupby(['only_date'],as_index=False).count()

pos = pos[['only_date','id']]
neg = neg[['only_date','id']]
neu = neu[['only_date','id']]

import plotly.graph_objs as go
import matplotlib.pyplot as plt

fig = go.Figure()
for col in pos.columns:
    fig.add_trace(go.Scatter(x=pos['only_date'], y=pos['id'],
                             name = "positive tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='green'
                             )
                 )

for col in neg.columns:
    fig.add_trace(go.Scatter(x=neg['only_date'], y=neg['id'],
                             name = "negative tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='red'
                             )
                 )

for col in neu.columns:
    fig.add_trace(go.Scatter(x=neu['only_date'], y=neu['id'],
                             name = "neutral tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='orange'
                             )
                 )

fig.update_layout(
    title_font_family="Arial",
    title_font_color="black",
    #title_font_size=30,
    title="Timeline: sentiments in the %s tweets (whole dataset)" % myName
)

fig.write_html("Timeline_sentiments_whole_"+myUrl+".html")

fig.show()

hap = MyData_en[MyData_en['Happy']!=0.0]
hap = hap.groupby(['only_date'],as_index=False).count()

ang = MyData_en[MyData_en['Angry']!=0.0]
ang = ang.groupby(['only_date'],as_index=False).count()

sur = MyData_en[MyData_en['Surprise']!=0.00]
sur = sur.groupby(['only_date'],as_index=False).count()

sad = MyData_en[MyData_en['Sad']!=0.0]
sad = sad.groupby(['only_date'],as_index=False).count()

fea = MyData_en[MyData_en['Fear']!=0.00]
fea = fea.groupby(['only_date'],as_index=False).count()

neut = MyData_en[(MyData_en['Happy']==0.0) & (MyData_en['Angry']==0.0) & (MyData_en['Surprise']==0.00) & (MyData_en['Sad']==0.0) & (MyData_en['Fear']==0.00)]
neut = neut.groupby(['only_date'],as_index=False).count()

hap = hap[['only_date','id']]
ang = ang[['only_date','id']]
sur = sur[['only_date','id']]
sad = sad[['only_date','id']]
fea = fea[['only_date','id']]
neut = neut[['only_date','id']]

import plotly.graph_objs as go

fig = go.Figure()
for col in hap.columns:
    fig.add_trace(go.Scatter(x=hap['only_date'], y=hap['id'],
                             name = "tweets with non-zero Happy scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='green'
                             )
                 )

for col in ang.columns:
    fig.add_trace(go.Scatter(x=ang['only_date'], y=ang['id'],
                             name = "tweets with non-zero Angry scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='red'
                             )
                 )

for col in sur.columns:
    fig.add_trace(go.Scatter(x=sur['only_date'], y=sur['id'],
                             name = "tweets with non-zero Surprise scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='yellow'
                             )
                 )

for col in sad.columns:
    fig.add_trace(go.Scatter(x=sad['only_date'], y=sad['id'],
                             name = "tweets with non-zero Sad scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='blue'
                             )
                 )

for col in fea.columns:
    fig.add_trace(go.Scatter(x=fea['only_date'], y=fea['id'],
                             name = "tweets with non-zero Fear scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='black'
                             )
                 )

for col in neut.columns:
    fig.add_trace(go.Scatter(x=neut['only_date'], y=neut['id'],
                             name = "neutral tweets with all zero scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='orange'
                             )
                 )
fig.update_layout(
    title_font_family="Arial",
    title_font_color="black",
    #title_font_size=30,
    title="Timeline: emotions in the %s tweets (whole dataset)" % myName
)

fig.write_html("Timeline_emotions_whole_"+myUrl+".html")

fig.show()

"""### **Most frequent** word pairs and their bigrams

#### Positive / Negative
"""

# Get a bunch of tools from nltk

import nltk
nltk.download('punkt')
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk import word_tokenize

# Import bigrams
from nltk import bigrams

import itertools

# Get English stopwords
en_stopwords = set(stopwords.words('english'))

# Get the bigrams for positive sentiment

# Subset the data
myDataPos = MyData_en[MyData_en['sentiment_cat']=='positive']

# Tokenise each review
myTokensPos = [word_tokenize(review) for review in myDataPos['clean_content']]

# Remove stopwords and lowercase all
# Note that len(review)>2 will make sure at least three words are in a review.
myTokensPos_noSW_noCase = [[word.lower() for word in review if (len(review)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for review in myTokensPos]

# Generate lists of bigrams
myBigramPos = [list(bigrams(review)) for review in myTokensPos_noSW_noCase]

# Put all lists together
myBigramListPos = list(itertools.chain.from_iterable(myBigramPos))

# Get the most frequent ones
bigramFreqPos = FreqDist(myBigramListPos)
bigramFreqPos.most_common(50)

# Get the bigrams for negative sentiment

# Subset the data
myDataNeg = MyData_en[MyData_en['sentiment_cat']=='negative']

# Tokenise each review
myTokensNeg = [word_tokenize(review) for review in myDataNeg['clean_content']]

# Remove stopwords and lowercase all
# Note that len(review)>2 will make sure at least three words are in a review.
myTokensNeg_noSW_noCase = [[word.lower() for word in review if (len(review)>1) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for review in myTokensNeg]

# Generate lists of bigrams
myBigramNeg = [list(bigrams(review)) for review in myTokensNeg_noSW_noCase]

# Put all lists together
myBigramListNeg = list(itertools.chain.from_iterable(myBigramNeg))

# Get the most frequent ones
bigramFreqNeg = FreqDist(myBigramListNeg)
bigramFreqNeg.most_common(50)

# Convert the result to a dataframe for visualisation
#myDF2Neg = pd.DataFrame(bigramFreqNeg.most_common(30), columns=['word', 'frequency'])

# Prepare the bigram networks

# We need some libraries
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
import matplotlib.pyplot as plt

# Collect the result
myResultPos = bigramFreqPos.most_common(50)
myResultNeg = bigramFreqNeg.most_common(50)

# Construct the network for positives
G_pos = nx.Graph()

# Create connections between nodes
for i in myResultPos:
    G_pos.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Construct the network for negatives
G_neg = nx.Graph()

# Create connections between nodes
for i in myResultNeg:
    G_neg.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(1, 2, figsize=(40, 15))

# Subplot1 for positives

# use another layout
#pos_pos = graphviz_layout(G_pos, prog="neato")
pos_pos = nx.spring_layout(G_pos, k=7, seed=9165, iterations=400)

# store the node label information
labelsPos = {}
for node in G_pos.nodes:
    labelsPos[node] = node

# Plot edges
nx.draw_networkx_edges(G_pos, pos_pos, width=2, alpha=0.3, ax=ax[0])
#nx.draw_networkx_edges(G, pos_pos, width=2, alpha=0.3 )


# Plot nodes
nx.draw_networkx_nodes(G_pos, pos_pos, alpha=0.2, label=True, ax=ax[0])

# Add labels
nx.draw_networkx_labels(G_pos, pos_pos, labelsPos, ax=ax[0])

# Turn off the axis
ax[0].axis("off")
# Add title
ax[0].set_title('Positive tweets',fontsize=30)


# Subplot2 for negatives

# use another layout
#pos_neg = graphviz_layout(G_neg, prog="neato")
pos_neg = nx.spring_layout(G_neg, k=7, seed=9165, iterations=400)
#pos_neg = nx.fruchterman_reingold_layout(G_neg, k=5, seed=9165, iterations=400)

# store the node label information
labelsNeg = {}
for node in G_neg.nodes:
    labelsNeg[node] = node

# Plot edges
nx.draw_networkx_edges(G_neg, pos_neg, width=2, alpha=0.3, ax=ax[1])

# Plot nodes
nx.draw_networkx_nodes(G_neg, pos_neg, alpha=0.2,  label=True, ax=ax[1], node_color='red')

# Add labels
nx.draw_networkx_labels(G_neg, pos_neg, labelsNeg, ax=ax[1])

# Add a title
# Use y to increase space
f.suptitle('Bigrams of positive / negative tweets: %s (whole dataset)' % myName,y=1.01, fontsize=36)

# Turn off the axis
ax[1].axis("off")
# Add title
ax[1].set_title('Negative tweets',fontsize=30)

# Save the figure
plt.savefig('conditionalBigram_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Pos = pd.DataFrame(bigramFreqPos.most_common(30), columns=['word', 'frequency'])

# Convert the result to a dataframe for visualisation
myDF2Neg = pd.DataFrame(bigramFreqNeg.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(1, 2,
                     figsize=(12,12)
                     )

# Barplot for positive tweets
sns.barplot(x="frequency",
            y="word",
            data=myDF2Pos,
            palette="rocket",
            ax=ax[0]
            )

ax[0].set_title('Positive',fontsize=25)
ax[0].set_ylabel('')

# Barplot for negative tweets
sns.barplot(x="frequency",
            y="word",
            data=myDF2Neg,
            palette="mako",
            ax=ax[1]
            )

ax[1].set_title('Negative',fontsize=25)
ax[1].set_ylabel('')

# Leave some space between subplots
# Try commenting it out
plt.subplots_adjust(wspace=1.2)

# Add a title
# Use y to increase space
f.suptitle('Most frequent word pairs of positive / negative tweets: %s (whole dataset)' % myName,y=0.99, fontsize=24)


# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig('conditionalBigramFreq_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

"""#### Most frequent word pairs in the 5 feelings"""

# Get the bigrams for positive sentiment

# Subset the data
myDataHap = MyData_en[MyData_en['Happy']!=0.0]

# Tokenise each tweet
myTokensHap = [word_tokenize(tweet) for tweet in myDataHap['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensHap_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensHap]

# Generate lists of bigrams
myBigramHap = [list(bigrams(tweet)) for tweet in myTokensHap_noSW_noCase]

# Put all lists together
myBigramListHap = list(itertools.chain.from_iterable(myBigramHap))

# Get the most frequent ones
bigramFreqHap = FreqDist(myBigramListHap)
bigramFreqHap.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultHap = bigramFreqHap.most_common(50)

# Construct the network
G_Hap = nx.Graph()

# Create connections between nodes
for i in myResultHap:
    G_Hap.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Hap = nx.spring_layout(G_Hap, k=10, seed=9165, iterations=400)

# store the node label information
labels_Hap = {}
for node in G_Hap.nodes:
    labels_Hap[node] = node

# Plot edges
nx.draw_networkx_edges(G_Hap, Hap, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Hap, Hap, alpha=0.2, label=True, node_color='green')

# Add labels
nx.draw_networkx_labels(G_Hap, Hap, labels_Hap)

# Add title
ax.set_title('Bigrams of tweets with Non-Zero Happy emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Happy_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Hap = pd.DataFrame(bigramFreqHap.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Hap,
            #palette="flare"
            #palette="mako"
            palette="crest"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Happy word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Happy_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Angry"""

# Get the bigrams for positive sentiment

# Subset the data
myDataAng = MyData_en[MyData_en['Angry']!=0.0]

# Tokenise each tweet
myTokensAng = [word_tokenize(tweet) for tweet in myDataAng['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensAng_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensAng]

# Generate lists of bigrams
myBigramAng = [list(bigrams(tweet)) for tweet in myTokensAng_noSW_noCase]

# Put all lists together
myBigramListAng = list(itertools.chain.from_iterable(myBigramAng))

# Get the most frequent ones
bigramFreqAng = FreqDist(myBigramListAng)
bigramFreqAng.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultAng = bigramFreqAng.most_common(50)

# Construct the network
G_Ang = nx.Graph()

# Create connections between nodes
for i in myResultAng:
    G_Ang.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Ang = nx.spring_layout(G_Ang, k=10, seed=9165, iterations=400)

# store the node label information
labels_Ang = {}
for node in G_Ang.nodes:
    labels_Ang[node] = node

# Plot edges
nx.draw_networkx_edges(G_Ang, Ang, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Ang, Ang, alpha=0.2, label=True, node_color='red')

# Add labels
nx.draw_networkx_labels(G_Ang, Ang, labels_Ang)

# Add title
ax.set_title('Bigrams of tweets with Non-Zero Angry emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Angry_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Ang = pd.DataFrame(bigramFreqAng.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Ang,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            palette="dark:salmon_r"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Angry word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Angry_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Surprise"""

# Get the bigrams for positive sentiment

# Subset the data
myDataSur = MyData_en[MyData_en['Surprise']!=0.00]

# Tokenise each tweet
myTokensSur = [word_tokenize(tweet) for tweet in myDataSur['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensSur_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensSur]

# Generate lists of bigrams
myBigramSur = [list(bigrams(tweet)) for tweet in myTokensSur_noSW_noCase]

# Put all lists together
myBigramListSur = list(itertools.chain.from_iterable(myBigramSur))

# Get the most frequent ones
bigramFreqSur = FreqDist(myBigramListSur)
bigramFreqSur.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultSur = bigramFreqSur.most_common(50)

# Construct the network
G_Sur = nx.Graph()

# Create connections between nodes
for i in myResultSur:
    G_Sur.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Sur = nx.spring_layout(G_Sur, k=10, seed=9165, iterations=400)

# store the node label information
labels_Sur = {}
for node in G_Sur.nodes:
    labels_Sur[node] = node

# Plot edges
nx.draw_networkx_edges(G_Sur, Sur, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Sur, Sur, alpha=0.2, label=True, node_color='yellow')

# Add labels
nx.draw_networkx_labels(G_Sur, Sur, labels_Sur)

# Add title
ax.set_title('Bigrams of tweets with Non-Zero Surprise emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Surprise_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Sur = pd.DataFrame(bigramFreqSur.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Sur,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            palette="YlOrBr"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Surprise word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Surprise_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Sad"""

# Get the bigrams for positive sentiment

# Subset the data
myDataSad = MyData_en[MyData_en['Sad']!=0.00]

# Tokenise each tweet
myTokensSad = [word_tokenize(tweet) for tweet in myDataSad['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensSad_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensSad]

# Generate lists of bigrams
myBigramSad = [list(bigrams(tweet)) for tweet in myTokensSad_noSW_noCase]

# Put all lists together
myBigramListSad = list(itertools.chain.from_iterable(myBigramSad))

# Get the most frequent ones
bigramFreqSad = FreqDist(myBigramListSad)
bigramFreqSad.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultSad = bigramFreqSad.most_common(50)

# Construct the network
G_Sad = nx.Graph()

# Create connections between nodes
for i in myResultSad:
    G_Sad.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Sad = nx.spring_layout(G_Sad, k=10, seed=9165, iterations=400)

# store the node label information
labels_Sad = {}
for node in G_Sad.nodes:
    labels_Sad[node] = node

# Plot edges
nx.draw_networkx_edges(G_Sad, Sad, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Sad, Sad, alpha=0.2, label=True, node_color='blue')

# Add labels
nx.draw_networkx_labels(G_Sad, Sad, labels_Sad)

# Add title
ax.set_title('Bigrams of tweets with Non-Zero Sad emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Sad_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Sad = pd.DataFrame(bigramFreqSad.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Sad,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            palette="light:b_r"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Sad word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Sad_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Fear"""

# Get the bigrams for Fear emotion sentiment

# Subset the data
myDataFea = MyData_en[MyData_en['Fear']!=0.00]

# Tokenise each tweet
myTokensFea = [word_tokenize(tweet) for tweet in myDataFea['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensFea_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensFea]

# Generate lists of bigrams
myBigramFea = [list(bigrams(tweet)) for tweet in myTokensFea_noSW_noCase]

# Put all lists together
myBigramListFea = list(itertools.chain.from_iterable(myBigramFea))

# Get the most frequent ones
bigramFreqFea = FreqDist(myBigramListFea)
bigramFreqFea.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultFea = bigramFreqFea.most_common(50)

# Construct the network
G_Fea = nx.Graph()

# Create connections between nodes
for i in myResultFea:
    G_Fea.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Fea = nx.spring_layout(G_Fea, k=10, seed=9165, iterations=400)

# store the node label information
labels_Fea = {}
for node in G_Fea.nodes:
    labels_Fea[node] = node

# Plot edges
nx.draw_networkx_edges(G_Fea, Fea, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Fea, Fea, alpha=0.2, label=True, node_color='black')

# Add labels
nx.draw_networkx_labels(G_Fea, Fea, labels_Fea)

# Add title
ax.set_title('Bigrams of tweets with Non-Zero Fear emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Fear_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Fea = pd.DataFrame(bigramFreqFea.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Fea,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            #palette="light:b_r"
            #palette="dark:salmon"
            palette="dark:#69d"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Fear word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Fear_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Neutral emotions"""

# Get the bigrams for Fear emotion sentiment

# Subset the data
myDataNeut = MyData_en[(MyData_en['Happy']==0.0) & (MyData_en['Angry']==0.0) & (MyData_en['Surprise']==0.00) & (MyData_en['Sad']==0.0) & (MyData_en['Fear']==0.00)]

# Tokenise each tweet
myTokensNeut = [word_tokenize(tweet) for tweet in myDataNeut['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensNeut_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensNeut]

# Generate lists of bigrams
myBigramNeut = [list(bigrams(tweet)) for tweet in myTokensNeut_noSW_noCase]

# Put all lists together
myBigramListNeut = list(itertools.chain.from_iterable(myBigramNeut))

# Get the most frequent ones
bigramFreqNeut = FreqDist(myBigramListNeut)
bigramFreqNeut.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultNeut = bigramFreqNeut.most_common(50)

# Construct the network
G_Neut = nx.Graph()

# Create connections between nodes
for i in myResultNeut:
    G_Neut.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Neut = nx.spring_layout(G_Neut, k=10, seed=9165, iterations=400)

# store the node label information
labels_Neut = {}
for node in G_Neut.nodes:
    labels_Neut[node] = node

# Plot edges
nx.draw_networkx_edges(G_Neut, Neut, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Neut, Neut, alpha=0.2, label=True, node_color='orange')

# Add labels
nx.draw_networkx_labels(G_Neut, Neut, labels_Neut)

# Add title
ax.set_title('Bigrams of tweets with All-Zero Neutral emotions: %s (whole dataset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('bigram_Neutral_whole_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Neut = pd.DataFrame(bigramFreqNeut.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Neut,
            palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            #palette="light:b_r"
            #palette="dark:salmon"
            #palette="dark:#69d"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Neutral word pairs: %s (whole dataset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("top30_Neutral_whole_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()







"""## ***Subset: "51" OR "attack" OR "double"***

### **Creating** subset
"""

# Create a new dataframe with tweets containing 51 or attack
#define values
values = ['51', 'attack', 'Attack', 'double', 'Double']

#keep rows that contain any value in the list
MyData_en_sub = MyData_en[MyData_en.content.str.contains('|'.join(values))]

MyData_en_sub.describe()

# drop rows which have same clean_content
# and user and keep last (first appearance in time) entry
MyData_en_sub = MyData_en_sub.drop_duplicates(
  subset = ['clean_content', 'user'],
  keep = 'last').reset_index(drop = True)

MyData_en_sub.describe()

MyData_en_sub.to_csv('Dataset_sub_'+myUrl+'.csv')



"""### Get the **statistics** for the subset"""

MyData_en_sub[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']].describe()

MyData_en_sub[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']].value_counts()

#melt data frame into long format
df_melted_sub = pd.melt(MyData_en_sub[['Happy', 'Angry', 'Surprise', 'Sad', 'Fear']])

#view first 10 rows of melted data frame
#df_melted_sub.head(10)

import matplotlib.pyplot as plt
import seaborn as sns

#create seaborn boxplots by group
sns.boxplot(x='variable', y='value', data=df_melted_sub, palette=["green", "red", "gold", "blue", "black"]).set(title='Emotion sentiments: %s (subset)' % myName)

#modify axis labels
plt.xlabel('')
plt.ylabel('')

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("emotion_sentiments_sub_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

MyData_en_sub[['sentiment_cat']].value_counts()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(8,8),
                     sharey=True
                     )

sns.countplot(x="sentiment_cat",
            data=MyData_en_sub,
            order=['negative', 'neutral', 'positive'], # specify the ordering
            palette=["red", "orange", "green"]
            #palette="flare",
            )

ax.set_title('Total sentiments: %s (subset)' % myName,size=24)
ax.set_xlabel('')

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("sentiments_subset_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""### **Timeline** of 51 attack tweets per day"""

neg_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='negative']
neg_sub = neg_sub.groupby(['only_date'],as_index=False).count()

pos_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='positive']
pos_sub = pos_sub.groupby(['only_date'],as_index=False).count()

neu_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='neutral']
neu_sub = neu_sub.groupby(['only_date'],as_index=False).count()

pos_sub = pos_sub[['only_date','id']]
neg_sub = neg_sub[['only_date','id']]
neu_sub = neu_sub[['only_date','id']]

import plotly.graph_objs as go
import matplotlib.pyplot as plt

fig = go.Figure()
for col in pos_sub.columns:
    fig.add_trace(go.Scatter(x=pos_sub['only_date'], y=pos_sub['id'],
                             name = "positive 51 attack tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='green'
                             )
                 )

for col in neg_sub.columns:
    fig.add_trace(go.Scatter(x=neg_sub['only_date'], y=neg_sub['id'],
                             name = "negative 51 attack tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='red'
                             )
                 )

for col in neu_sub.columns:
    fig.add_trace(go.Scatter(x=neu_sub['only_date'], y=neu_sub['id'],
                             name = "neutral 51 attack tweets",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='orange'
                             )
                 )

fig.update_layout(
    title_font_family="Arial",
    title_font_color="black",
    #title_font_size=30,
    title="Timeline of sentiments in the %s tweets (subset)" % myName
)

fig.write_html("Timeline_sentiments_subset_"+myUrl+".html")

fig.show()

hap_sub = MyData_en_sub[MyData_en_sub['Happy']!=0.0]
hap_sub = hap_sub.groupby(['only_date'],as_index=False).count()

ang_sub = MyData_en_sub[MyData_en_sub['Angry']!=0.0]
ang_sub = ang_sub.groupby(['only_date'],as_index=False).count()

sur_sub = MyData_en_sub[MyData_en_sub['Surprise']!=0.00]
sur_sub = sur_sub.groupby(['only_date'],as_index=False).count()

sad_sub = MyData_en_sub[MyData_en_sub['Sad']!=0.0]
sad_sub = sad_sub.groupby(['only_date'],as_index=False).count()

fea_sub = MyData_en_sub[MyData_en_sub['Fear']!=0.00]
fea_sub = fea_sub.groupby(['only_date'],as_index=False).count()

neut_sub = MyData_en_sub[(MyData_en_sub['Happy']==0.0) & (MyData_en_sub['Angry']==0.0) & \
                         (MyData_en_sub['Surprise']==0.00) & (MyData_en_sub['Sad']==0.0) & \
                         (MyData_en_sub['Fear']==0.00)]
neut_sub = neut_sub.groupby(['only_date'],as_index=False).count()

hap_sub = hap_sub[['only_date','id']]
ang_sub = ang_sub[['only_date','id']]
sur_sub = sur_sub[['only_date','id']]
sad_sub = sad_sub[['only_date','id']]
fea_sub = fea_sub[['only_date','id']]
neut_sub = neut_sub[['only_date','id']]

import plotly.graph_objs as go

fig = go.Figure()
for col in hap_sub.columns:
    fig.add_trace(go.Scatter(x=hap_sub['only_date'], y=hap_sub['id'],
                             name = "51 attack tweets with non-zero Happy scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='green'
                             )
                 )

for col in ang_sub.columns:
    fig.add_trace(go.Scatter(x=ang_sub['only_date'], y=ang_sub['id'],
                             name = "51 attack tweets with non-zero Angry scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='red'
                             )
                 )

for col in sur_sub.columns:
    fig.add_trace(go.Scatter(x=sur_sub['only_date'], y=sur_sub['id'],
                             name = "51 attack tweets with non-zero Surprise scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='yellow'
                             )
                 )

for col in sad_sub.columns:
    fig.add_trace(go.Scatter(x=sad_sub['only_date'], y=sad_sub['id'],
                             name = "51 attack tweets with non-zero Sad scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='blue'
                             )
                 )

for col in fea_sub.columns:
    fig.add_trace(go.Scatter(x=fea_sub['only_date'], y=fea_sub['id'],
                             name = "51 attack tweets with non-zero Fear scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='black'
                             )
                 )

for col in neut_sub.columns:
    fig.add_trace(go.Scatter(x=neut_sub['only_date'], y=neut_sub['id'],
                             name = "51 attack neutral tweets with all zero scores",
                             mode = 'markers+lines',
                             line=dict(shape='linear'),
                             connectgaps=True,
                             line_color='orange'
                             )
                 )
fig.update_layout(
    title_font_family="Arial",
    title_font_color="black",
    #title_font_size=30,
    title="Timeline of emotions in the %s tweets (subset)" % myName
)

fig.write_html("Timeline_emotions_subset_"+myUrl+".html")

fig.show()

"""### **Timeline** of 51 attack tweets per day (updated figure)

---


"""

import pandas as pd
MyData_en_sub = pd.read_csv('Dataset_sub_bitcoingold_22_01_2020.csv')
MyData_en_sub.info()

neg_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='negative']
neg_sub = neg_sub.groupby(['only_date'],as_index=False).count()

pos_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='positive']
pos_sub = pos_sub.groupby(['only_date'],as_index=False).count()

neu_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='neutral']
neu_sub = neu_sub.groupby(['only_date'],as_index=False).count()

pos_sub = pos_sub[['only_date','id']]
neg_sub = neg_sub[['only_date','id']]
neu_sub = neu_sub[['only_date','id']]

import plotly.graph_objs as go
import matplotlib.pyplot as plt

fig = go.Figure()

fig.add_trace(go.Scatter(x=pos_sub['only_date'], y=pos_sub['id'],
                         name = "positive 51 attack tweets",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='green'
                         )
             )

fig.add_trace(go.Scatter(x=neg_sub['only_date'], y=neg_sub['id'],
                         name = "negative 51 attack tweets",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='red'
                         )
             )

fig.add_trace(go.Scatter(x=neu_sub['only_date'], y=neu_sub['id'],
                         name = "neutral 51 attack tweets",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='orange'
                         )
             )

fig.update_layout(
    plot_bgcolor='white',
    font_family = 'STIX',
    title_font_family='STIX',
    title_font_color="black",
    xaxis_title="Date",
    yaxis_title="Number of Tweets"
    #title_font_size=30,
    #title="Timeline of sentiments in the %s tweets (subset)" % myName
)

#Update the axis and labels with latex format
fig.update_xaxes(title_text="Date", title_font=dict(size=18, family='STIX'))
fig.update_yaxes(title_text="Number of Tweets", title_font=dict(size=18, family='STIX'))


fig.write_html("Timeline_sentiments_subset_BTGjan2020.html")

fig.show()

hap_sub = MyData_en_sub[MyData_en_sub['Happy']!=0.0]
hap_sub = hap_sub.groupby(['only_date'],as_index=False).count()

ang_sub = MyData_en_sub[MyData_en_sub['Angry']!=0.0]
ang_sub = ang_sub.groupby(['only_date'],as_index=False).count()

sur_sub = MyData_en_sub[MyData_en_sub['Surprise']!=0.00]
sur_sub = sur_sub.groupby(['only_date'],as_index=False).count()

sad_sub = MyData_en_sub[MyData_en_sub['Sad']!=0.0]
sad_sub = sad_sub.groupby(['only_date'],as_index=False).count()

fea_sub = MyData_en_sub[MyData_en_sub['Fear']!=0.00]
fea_sub = fea_sub.groupby(['only_date'],as_index=False).count()

neut_sub = MyData_en_sub[(MyData_en_sub['Happy']==0.0) & (MyData_en_sub['Angry']==0.0) & \
                         (MyData_en_sub['Surprise']==0.00) & (MyData_en_sub['Sad']==0.0) & \
                         (MyData_en_sub['Fear']==0.00)]
neut_sub = neut_sub.groupby(['only_date'],as_index=False).count()

hap_sub = hap_sub[['only_date','id']]
ang_sub = ang_sub[['only_date','id']]
sur_sub = sur_sub[['only_date','id']]
sad_sub = sad_sub[['only_date','id']]
fea_sub = fea_sub[['only_date','id']]
neut_sub = neut_sub[['only_date','id']]

import plotly.graph_objs as go

fig = go.Figure()

fig.add_trace(go.Scatter(x=hap_sub['only_date'], y=hap_sub['id'],
                         name = "51 attack tweets with non-zero Happy scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='green'
                         )
              )

fig.add_trace(go.Scatter(x=ang_sub['only_date'], y=ang_sub['id'],
                         name = "51 attack tweets with non-zero Angry scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='red'
                         )
                 )


fig.add_trace(go.Scatter(x=sur_sub['only_date'], y=sur_sub['id'],
                         name = "51 attack tweets with non-zero Surprise scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='yellow'
                         )
                 )

fig.add_trace(go.Scatter(x=sad_sub['only_date'], y=sad_sub['id'],
                         name = "51 attack tweets with non-zero Sad scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='blue'
                         )
                 )


fig.add_trace(go.Scatter(x=fea_sub['only_date'], y=fea_sub['id'],
                         name = "51 attack tweets with non-zero Fear scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='black'
                         )
                 )


fig.add_trace(go.Scatter(x=neut_sub['only_date'], y=neut_sub['id'],
                         name = "51 attack neutral tweets with all zero scores",
                         mode = 'markers+lines',
                         line=dict(shape='linear'),
                         connectgaps=True,
                         line_color='orange'
                         )
                 )
fig.update_layout(
    plot_bgcolor='white',
    title_font_family="Arial",
    title_font_color="black",
    xaxis_title="Date",
    yaxis_title="Number of Tweets"
    #title_font_size=30,
    #title="Timeline of emotions in the %s tweets (subset)" % myName
)

fig.write_html("Timeline_emotions_subset_BTGjan2020.html")

fig.show()



"""### **Most frequent** word pairs and their bigrams for the 51 attack subset

#### Positive / Negative (subset)
"""

# Get a bunch of tools from nltk

import nltk
nltk.download('punkt')
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk import word_tokenize

# Import bigrams
from nltk import bigrams

import itertools

# Get English stopwords
en_stopwords = set(stopwords.words('english'))

# Get the bigrams for positive sentiment

# Subset the data
myDataPos_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='positive']

# Tokenise each tweet
myTokensPos_sub = [word_tokenize(tweet) for tweet in myDataPos_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensPos_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensPos_sub]

# Generate lists of bigrams
myBigramPos_sub = [list(bigrams(tweet)) for tweet in myTokensPos_sub_noSW_noCase]

# Put all lists together
myBigramListPos_sub = list(itertools.chain.from_iterable(myBigramPos_sub))

# Get the most frequent ones
bigramFreqPos_sub = FreqDist(myBigramListPos_sub)
bigramFreqPos_sub.most_common(50)

# Get the bigrams for negative sentiment

# Subset the data
myDataNeg_sub = MyData_en_sub[MyData_en_sub['sentiment_cat']=='negative']

# Tokenise each tweet
myTokensNeg_sub = [word_tokenize(tweet) for tweet in myDataNeg_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensNeg_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>1) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensNeg_sub]

# Generate lists of bigrams
myBigramNeg_sub = [list(bigrams(tweet)) for tweet in myTokensNeg_sub_noSW_noCase]

# Put all lists together
myBigramListNeg_sub = list(itertools.chain.from_iterable(myBigramNeg_sub))

# Get the most frequent ones
bigramFreqNeg_sub = FreqDist(myBigramListNeg_sub)
bigramFreqNeg_sub.most_common(50)

# Prepare the bigram networks

# We need some libraries
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
import matplotlib.pyplot as plt

# Collect the result
myResultPos_sub = bigramFreqPos_sub.most_common(50)
myResultNeg_sub = bigramFreqNeg_sub.most_common(50)

# Construct the network for positives
G_pos_sub = nx.Graph()

# Create connections between nodes
for i in myResultPos_sub:
    G_pos_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Construct the network for negatives
G_neg_sub = nx.Graph()

# Create connections between nodes
for i in myResultNeg_sub:
    G_neg_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(1, 2, figsize=(40, 15))

# Subplot1 for positives

# use another layout
pos_sub = graphviz_layout(G_pos_sub, prog="neato")
#pos_pos = nx.spring_layout(G_pos, k=7, seed=9165, iterations=400)

# store the node label information
labelsPos_sub = {}
for node in G_pos_sub.nodes:
    labelsPos_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_pos_sub, pos_sub, width=2, alpha=0.3, ax=ax[0])
#nx.draw_networkx_edges(G, pos_pos, width=2, alpha=0.3 )


# Plot nodes
nx.draw_networkx_nodes(G_pos_sub, pos_sub, alpha=0.2, label=True, ax=ax[0])

# Add labels
nx.draw_networkx_labels(G_pos_sub, pos_sub, labelsPos_sub, ax=ax[0])

# Turn off the axis
ax[0].axis("off")
# Add title
ax[0].set_title('Positive',fontsize=30)


# Subplot2 for negatives

# use another layout
neg_sub = graphviz_layout(G_neg_sub, prog="neato")
#pos_neg = nx.spring_layout(G_neg, k=7, seed=9165, iterations=400)
#pos_neg = nx.fruchterman_reingold_layout(G_neg, k=5, seed=9165, iterations=400)

# store the node label information
labelsNeg_sub = {}
for node in G_neg_sub.nodes:
    labelsNeg_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_neg_sub, neg_sub, width=2, alpha=0.3, ax=ax[1])

# Plot nodes
nx.draw_networkx_nodes(G_neg_sub, neg_sub, alpha=0.2,  label=True, ax=ax[1], node_color='red')

# Add labels
nx.draw_networkx_labels(G_neg_sub, neg_sub, labelsNeg_sub, ax=ax[1])

# Turn off the axis
ax[1].axis("off")
# Add title
ax[1].set_title('Negative',fontsize=30)

# Add a title
# Use y to increase space
f.suptitle('Bigrams of positive / negative tweets: %s (subset)' % myName,y=1.01, fontsize=36)


# Save the figure
plt.savefig('subset_conditionalBigram_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Pos_sub = pd.DataFrame(bigramFreqPos_sub.most_common(30), columns=['word', 'frequency'])

# Convert the result to a dataframe for visualisation
myDF2Neg_sub = pd.DataFrame(bigramFreqNeg_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(1, 2,
                     figsize=(12,12)
                     )

# Barplot for positive tweets
sns.barplot(x="frequency",
            y="word",
            data=myDF2Pos_sub,
            palette="rocket",
            ax=ax[0]
            )

ax[0].set_title('Positive',fontsize=25)
ax[0].set_ylabel('')

# Barplot for negative tweets
sns.barplot(x="frequency",
            y="word",
            data=myDF2Neg_sub,
            palette="mako",
            ax=ax[1]
            )

ax[1].set_title('Negative',fontsize=25)
ax[1].set_ylabel('')

# Leave some space between subplots
# Try commenting it out
plt.subplots_adjust(wspace=1.2)

# Add a title
# Use y to increase space
f.suptitle('Most frequent word pairs of positive / negative tweets: %s (subset)' % myName,y=1.01, fontsize=24)


# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig('subset_conditionalFreq_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()





"""#### Most frequent word pairs in the 5 feelings in the subset"""

# Get the bigrams for positive sentiment

# Subset the data
myDataHap_sub = MyData_en_sub[MyData_en_sub['Happy']!=0.0]

# Tokenise each tweet
myTokensHap_sub = [word_tokenize(tweet) for tweet in myDataHap_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensHap_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensHap_sub]

# Generate lists of bigrams
myBigramHap_sub = [list(bigrams(tweet)) for tweet in myTokensHap_sub_noSW_noCase]

# Put all lists together
myBigramListHap_sub = list(itertools.chain.from_iterable(myBigramHap_sub))

# Get the most frequent ones
bigramFreqHap_sub = FreqDist(myBigramListHap_sub)
bigramFreqHap_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultHap_sub = bigramFreqHap_sub.most_common(50)

# Construct the network
G_Hap_sub = nx.Graph()

# Create connections between nodes
for i in myResultHap_sub:
    G_Hap_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Hap_sub = nx.spring_layout(G_Hap_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Hap_sub = {}
for node in G_Hap_sub.nodes:
    labels_Hap_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Hap_sub, Hap_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Hap_sub, Hap_sub, alpha=0.2, label=True, node_color='green')

# Add labels
nx.draw_networkx_labels(G_Hap_sub, Hap_sub, labels_Hap_sub)

# Turn off the axis
ax.axis("off")
# Add title
ax.set_title('Non-Zero Happy emotions: %s (subset)' % myName,fontsize=24)

# Save the figure
plt.savefig('subset_bigram_Happy_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Hap_sub = pd.DataFrame(bigramFreqHap_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Hap_sub,
            #palette="flare"
            #palette="mako"
            palette="crest"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Happy word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Happy_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""Angry"""

# Get the bigrams for positive sentiment

# Subset the data
myDataAng_sub = MyData_en_sub[MyData_en_sub['Angry']!=0.0]

# Tokenise each tweet
myTokensAng_sub = [word_tokenize(tweet) for tweet in myDataAng_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensAng_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensAng_sub]

# Generate lists of bigrams
myBigramAng_sub = [list(bigrams(tweet)) for tweet in myTokensAng_sub_noSW_noCase]

# Put all lists together
myBigramListAng_sub = list(itertools.chain.from_iterable(myBigramAng_sub))

# Get the most frequent ones
bigramFreqAng_sub = FreqDist(myBigramListAng_sub)
bigramFreqAng_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultAng_sub = bigramFreqAng_sub.most_common(50)

# Construct the network
G_Ang_sub = nx.Graph()

# Create connections between nodes
for i in myResultAng_sub:
    G_Ang_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Ang_sub = nx.spring_layout(G_Ang_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Ang_sub = {}
for node in G_Ang_sub.nodes:
    labels_Ang_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Ang_sub, Ang_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Ang_sub, Ang_sub, alpha=0.2, label=True, node_color='red')

# Add labels
nx.draw_networkx_labels(G_Ang_sub, Ang_sub, labels_Ang_sub)

# Add title
ax.set_title('Non-Zero Angry emotions: %s (subset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('subset_bigram_Angry_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Ang_sub = pd.DataFrame(bigramFreqAng_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Ang_sub,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            palette="dark:salmon_r"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Angry word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Angry_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Surprise"""

# Get the bigrams for positive sentiment

# Subset the data
myDataSur_sub = MyData_en_sub[MyData_en_sub['Surprise']!=0.00]

# Tokenise each tweet
myTokensSur_sub = [word_tokenize(tweet) for tweet in myDataSur_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensSur_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensSur_sub]

# Generate lists of bigrams
myBigramSur_sub = [list(bigrams(tweet)) for tweet in myTokensSur_sub_noSW_noCase]

# Put all lists together
myBigramListSur_sub = list(itertools.chain.from_iterable(myBigramSur_sub))

# Get the most frequent ones
bigramFreqSur_sub = FreqDist(myBigramListSur_sub)
bigramFreqSur_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultSur_sub = bigramFreqSur_sub.most_common(50)

# Construct the network
G_Sur_sub = nx.Graph()

# Create connections between nodes
for i in myResultSur_sub:
    G_Sur_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Sur_sub = nx.spring_layout(G_Sur_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Sur_sub = {}
for node in G_Sur_sub.nodes:
    labels_Sur_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Sur_sub, Sur_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Sur_sub, Sur_sub, alpha=0.2, label=True, node_color='yellow')

# Add labels
nx.draw_networkx_labels(G_Sur_sub, Sur_sub, labels_Sur_sub)

# Add title
ax.set_title('Non-Zero Surprise emotions: %s (subset)',fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('subset_bigram_Surprise_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Sur_sub = pd.DataFrame(bigramFreqSur_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Sur_sub,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            palette="YlOrBr"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Surprise word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Surprise_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Sad"""

# Get the bigrams for positive sentiment

# Subset the data
myDataSad_sub = MyData_en_sub[MyData_en_sub['Sad']!=0.00]

# Tokenise each tweet
myTokensSad_sub = [word_tokenize(tweet) for tweet in myDataSad_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensSad_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensSad_sub]

# Generate lists of bigrams
myBigramSad_sub = [list(bigrams(tweet)) for tweet in myTokensSad_sub_noSW_noCase]

# Put all lists together
myBigramListSad_sub = list(itertools.chain.from_iterable(myBigramSad_sub))

# Get the most frequent ones
bigramFreqSad_sub = FreqDist(myBigramListSad_sub)
bigramFreqSad_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultSad_sub = bigramFreqSad_sub.most_common(50)

# Construct the network
G_Sad_sub = nx.Graph()

# Create connections between nodes
for i in myResultSad_sub:
    G_Sad_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Sad_sub = nx.spring_layout(G_Sad_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Sad_sub = {}
for node in G_Sad_sub.nodes:
    labels_Sad_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Sad_sub, Sad_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Sad_sub, Sad_sub, alpha=0.2, label=True, node_color='blue')

# Add labels
nx.draw_networkx_labels(G_Sad_sub, Sad_sub, labels_Sad_sub)

# Add title
ax.set_title('Non-Zero Sad emotions: %s (subset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('subset_bigram_Sad_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Sad_sub = pd.DataFrame(bigramFreqSad_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Sad_sub,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            palette="light:b_r"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Sad word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Sad_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Fear"""

# Get the bigrams for Fear emotion sentiment

# Subset the data
myDataFea_sub = MyData_en_sub[MyData_en_sub['Fear']!=0.00]

# Tokenise each tweet
myTokensFea_sub = [word_tokenize(tweet) for tweet in myDataFea_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensFea_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensFea_sub]

# Generate lists of bigrams
myBigramFea_sub = [list(bigrams(tweet)) for tweet in myTokensFea_sub_noSW_noCase]

# Put all lists together
myBigramListFea_sub = list(itertools.chain.from_iterable(myBigramFea_sub))

# Get the most frequent ones
bigramFreqFea_sub = FreqDist(myBigramListFea_sub)
bigramFreqFea_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultFea_sub = bigramFreqFea_sub.most_common(50)

# Construct the network
G_Fea_sub = nx.Graph()

# Create connections between nodes
for i in myResultFea_sub:
    G_Fea_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Fea_sub = nx.spring_layout(G_Fea_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Fea_sub = {}
for node in G_Fea_sub.nodes:
    labels_Fea_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Fea_sub, Fea_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Fea_sub, Fea_sub, alpha=0.2, label=True, node_color='black')

# Add labels
nx.draw_networkx_labels(G_Fea_sub, Fea_sub, labels_Fea_sub)

# Add title
ax.set_title('Non-Zero Fear emotions: %s (subset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('subset_bigram_Fear_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Fea_sub = pd.DataFrame(bigramFreqFea_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Fea_sub,
            #palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            #palette="light:b_r"
            #palette="dark:salmon"
            palette="dark:#69d"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Fear word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Fear_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Neutral emotions"""

# Get the bigrams for Fear emotion sentiment

# Subset the data
myDataNeut_sub = MyData_en_sub[(MyData_en_sub['Happy']==0.0) & (MyData_en_sub['Angry']==0.0) & \
                               (MyData_en_sub['Surprise']==0.00) & (MyData_en_sub['Sad']==0.0) & \
                               (MyData_en_sub['Fear']==0.00)]

# Tokenise each tweet
myTokensNeut_sub = [word_tokenize(tweet) for tweet in myDataNeut_sub['clean_content']]

# Remove stopwords and lowercase all
# Note that len(tweet)>2 will make sure at least three words are in a tweet.
myTokensNeut_sub_noSW_noCase = [[word.lower() for word in tweet if (len(tweet)>2) and
                            (word.lower() not in en_stopwords) and
                            (len(word)>3)] for tweet in myTokensNeut_sub]

# Generate lists of bigrams
myBigramNeut_sub = [list(bigrams(tweet)) for tweet in myTokensNeut_sub_noSW_noCase]

# Put all lists together
myBigramListNeut_sub = list(itertools.chain.from_iterable(myBigramNeut_sub))

# Get the most frequent ones
bigramFreqNeut_sub = FreqDist(myBigramListNeut_sub)
bigramFreqNeut_sub.most_common(50)

# Prepare the bigram network

# We need networkx
import networkx as nx

# Collect the result
myResultNeut_sub = bigramFreqNeut_sub.most_common(50)

# Construct the network
G_Neut_sub = nx.Graph()

# Create connections between nodes
for i in myResultNeut_sub:
    G_Neut_sub.add_edge(i[0][0], i[0][1], weight=(i[1]))

# Visualisation

# set up the figure
f, ax = plt.subplots(figsize=(15, 15))

# k controls distance between nodes
Neut_sub = nx.spring_layout(G_Neut_sub, k=10, seed=9165, iterations=400)

# store the node label information
labels_Neut_sub = {}
for node in G_Neut_sub.nodes:
    labels_Neut_sub[node] = node

# Plot edges
nx.draw_networkx_edges(G_Neut_sub, Neut_sub, width=2, alpha=0.3)

# Plot nodes
nx.draw_networkx_nodes(G_Neut_sub, Neut_sub, alpha=0.2, label=True, node_color='orange')

# Add labels
nx.draw_networkx_labels(G_Neut_sub, Neut_sub, labels_Neut_sub)

# Add title
ax.set_title('All-Zero Neutral emotions: %s (subset)' % myName,fontsize=24)

# Turn off the axis
ax.axis("off")

# Save the figure
plt.savefig('subset_bigram_Neutral_'+myUrl+'.png',
            bbox_inches='tight',
            dpi=400)

# Show nicely in the notebook
plt.show()

# Convert the result to a dataframe for visualisation
myDF2Neut_sub = pd.DataFrame(bigramFreqNeut_sub.most_common(30), columns=['word', 'frequency'])

# Set a more specific style
sns.set_theme(style="white", context="talk")

#sns.set_theme(style="white")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(18,16))

# x and y will control if the barplot is horizontal or vertical
sns.barplot(x="frequency",
            y="word",
            data=myDF2Neut_sub,
            palette="flare"
            #palette="mako"
            #palette="crest"
            #palette="dark:salmon_r"
            #palette="YlOrBr"
            #palette="ch:start=.2,rot=-.3"
            #palette="light:b_r"
            #palette="dark:salmon"
            #palette="dark:#69d"
            )

# Add label to horiztontal axis
ax.set_xlabel("Frequency")

# Remove ylabel
ax.set_ylabel("")

# Add a title
ax.set_title("Top 30 Neutral word pairs: %s (subset)" % myName, fontsize = 24)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("subset_top30_Neutral_"+myUrl+".png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""# **Visualisation of results**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""### Sentiments for all the events"""

#MyData = pd.read_csv('summary_sent3_updated_may.csv')
MyData = pd.read_csv('summary_sent3_updated_sept2023.csv')
MyData.head()

# splitting into 2 the dataset: whole and subset
MyData_whole = MyData[MyData['dataset'] == 'whole']
MyData_sub = MyData[MyData['dataset'] == 'subset']

"""Sentiments: whole datasets"""

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_whole[['positive %', 'neutral %', 'negative %']].plot(kind='barh',
                                                             stacked=True,
                                                             width=0.7,
                                                             figsize=(10, 8),
                                                             use_index=True,
                                                             #order=['negative', 'neutral', 'positive'], # specify the ordering
                                                             colormap='Pastel2',
                                                             ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
#plt.legend(loc="upper right", ncol=1)
plt.xlabel(r'$Proportion\ of\ Sentiments\ SP(W_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')

ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$positive$', r'$neutral$', r'$negative$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Sentiments around 51% attacks (whole datasets)", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("sentiments_whole.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("sentiments_whole.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Sentiments: subsets"""

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_sub[['positive %', 'neutral %', 'negative %']].plot(kind='barh',
                                                             stacked=True,
                                                             width=0.7,
                                                             figsize=(10, 8),
                                                             use_index=True,
                                                             #order=['negative', 'neutral', 'positive'], # specify the ordering
                                                             colormap='Pastel2',
                                                             ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Proportion\ of\ Sentiments\ SP(A_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')


ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$positive$', r'$neutral$', r'$negative$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Sentiments around 51% attacks (subsets)", y=1.1, fontsize = 24)



# Save the figure
plt.savefig("sentiments_sub.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("sentiments_sub.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Sentiments: benchmark datasets"""

#MyData_b = pd.read_csv('benchmark_sent2_updated_may.csv')
MyData_b = pd.read_csv('benchmark_sent2_updated_sept2023.csv')
MyData_b.head()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_b[['positive %', 'neutral %', 'negative %']].plot(kind='barh',
                                                             stacked=True,
                                                             width=0.7,
                                                             figsize=(10, 8),
                                                             use_index=True,
                                                             #order=['negative', 'neutral', 'positive'], # specify the ordering
                                                             colormap='Pastel2',
                                                             ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Proportion\ of\ Sentiments\ SP(B_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')


ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$positive$', r'$neutral$', r'$negative$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Sentiments in the Benchmark datasets)", y=1.1, fontsize = 24)



# Save the figure
plt.savefig("sentiments_benchmark.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("sentiments_benchmark.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""### Emotions for all datasets

Emotions: whole dataset
"""

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_whole[['happy %', 'angry %', 'surprised %', 'sad %', 'fear %']].plot(kind='barh',
                                                                           stacked=True,
                                                                           width=0.7,
                                                                           figsize=(10, 8),
                                                                           use_index=True,
                                                                           colormap='Pastel2',                                                                           #colormap='Pastel2',
                                                                           ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
#plt.legend(loc="upper right", ncol=1)
plt.xlabel(r'$Proportion\ of\ Emotions\ Intensity\ EI(W_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')

ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$happy$', r'$angry$', r'$surprised$', r'$sad$', r'$fear$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Emotions around 51% attacks (whole datasets)", y=1.1, fontsize = 24)



# Save the figure
plt.savefig("emotions_whole.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("semotions_whole.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Emotions: subset"""

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_sub[['happy %', 'angry %', 'surprised %', 'sad %', 'fear %']].plot(kind='barh',
                                                                           stacked=True,
                                                                           width=0.7,
                                                                           figsize=(10, 8),
                                                                           use_index=True,
                                                                           colormap='Pastel2',                                                                           #colormap='Pastel2',
                                                                           ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
#plt.legend(loc="upper right", ncol=1)
plt.xlabel(r'$Proportion\ of\ Emotions\ Intensity\ EI(A_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')

ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$happy$', r'$angry$', r'$surprised$', r'$sad$', r'$fear$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Emotions around 51% attacks (subset)", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("emotions_sub.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotions_sub.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Emotions: benchmark"""

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX
def format_func(value, tick_number):
    return r'$%s$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(10,8))

MyData_b[['happy %', 'angry %', 'surprised %', 'sad %', 'fear %']].plot(kind='barh',
                                                                           stacked=True,
                                                                           width=0.7,
                                                                           figsize=(10, 8),
                                                                           use_index=True,
                                                                           colormap='Pastel2',                                                                           #colormap='Pastel2',
                                                                           ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
#plt.legend(loc="upper right", ncol=1)
plt.xlabel(r'$Proportion\ of\ Emotions\ Intensity\ EI(B_{i})\ (in\ \%)$')
plt.ylabel(r'$Events$')

ax.set_yticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the x-axis
ax.xaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$happy$', r'$angry$', r'$surprised$', r'$sad$', r'$fear$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

#reverse y-axis
plt.gca().invert_yaxis()

# Remove the border line
sns.despine(left=True, bottom=True)

# Add a title
#plt.title("Proportion of Emotions in the benchmark datasets", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("emotions_benchmark.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotions_benchmark.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

"""Emotions: proportions and combined proportions (whole, sub and benchmark)"""

import pandas as pd
#MyData_e = pd.read_csv('summary_sent4_updated_may.csv')
MyData_e = pd.read_csv('summary_sent4_updated_sept2023.csv')
MyData_e.head()

# splitting into 2 the dataset: whole and subset
MyData_e_whole = MyData_e[MyData_e['dataset'] == 'whole']
MyData_e_sub = MyData_e[MyData_e['dataset'] == 'subset']

# set 51% Attack column as index and drop the columns that are not needed

MyData_e_whole_hm  = MyData_e_whole.drop(columns=['dataset', '51% Attack', 'happy_nonZero', \
                                                    'angry_nonZero', 'surprise_nonZero', \
                                                    'sad_nonZero', 'fear_nonZero', \
                                                    'happy_nonZero%', 'angry_nonZero%', 'surprise_nonZero%', \
                                                    'sad_nonZero%', 'fear_nonZero%', \
                                                    'happy_angry_surprise_sad_fear_allZero%_1', \
                                                    'happy_only', 'angry_only', 'surprise_only', \
                                                    'sad_only', 'fear_only', \
                                                    'happy_angry', 'happy_surprise', \
                                                    'happy_sad', 'happy_fear', \
                                                    'angry_surprise', 'angry_sad', \
                                                    'angry_fear', 'surprise_sad', \
                                                    'surprise_fear', 'sad_fear', \
                                                    'happy_angry_surprise', 'happy_angry_sad', \
                                                    'happy_angry_fear', 'happy_surprise_sad', \
                                                    'happy_surprise_fear', 'happy_sad_fear', \
                                                    'angry_surprise_sad', 'angry_surprise_fear', \
                                                    'angry_sad_fear', 'surprise_sad_fear', \
                                                    'happy_angry_surprise_sad', 'happy_angry_surprise_fear', \
                                                    'happy_surprise_sad_fear', 'angry_surprise_sad_fear', \
                                                    'happy_angry_surprise_sad_fear', \
                                                    'happy_angry_surprise_sad_fear_allZero'], axis=1)
MyData_e_whole_hm

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(20,8))

sns.heatmap(data=MyData_e_whole_hm,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Proportion\ of\ Emotion\ Volumes\ EV(W_{i})$')
plt.ylabel(r'$Events$')

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((-0.5,0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5, \
               14.5,15.5,16.5,17.5,18.5,19.5,20.5,21.5,22.5,23.5,24.5,25.5,26.5,27.5,28.5,30))
ax.set_xticklabels(('$(HV,-,-,-,-)$', '$(-,AV,-,-,-)$', '$(-,-,SV,-,-)$', '$(-,-,-,DV,-)$', \
                    '$(-,-,-,-,FV)$', '$(HV,AV,-,-,-)$', '$(HV,-,SV,-,-)$', \
                    '$(HV,-,-,DV,-)$', '$(HV,-,-,-,FV)$', '$(-,AV,SV,-,-)$', \
                    '$(-,AV,-,DV,-)$', '$(-,AV,-,-,FV)$', '$(-,-,SV,DV,-)$', \
                    '$(-,-,SV,-,FV)$', '$(-,-,-,DV,FV)$', '$(HV,AV,SV,-,-)$', \
                    '$(HV,AV,-,DV,-)$', '$(HV,AV,-,-,FV)$', '$(HV,-,SV,DV,-)$', \
                    '$(HV,-,SV,-,FV)$', '$(HV,-,-,DV,FV)$', '$(-,AV,SV,DV,-)$', \
                    '$(-,AV,SV,-,FV)$', '$(-,AV,-,DV,FV)$', '$(-,-,SV,DV,FV)$', \
                    '$(HV,AV,SV,DV,-)$', '$(HV,AV,SV,-,FV)$', '$(HV,-,SV,DV,FV)$', \
                    '$(-,AV,SV,DV,FV)$', '$(HV,AV,SV,DV,FV)$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of Emotion combinations (in %) across the whole datasets ", y=1.1, fontsize = 24)



# Save the figure
plt.savefig("emotion_proportion_whole.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_v_prop_whole.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

plt.show()

# set 51% Attack column as index and drop the columns that are not needed

MyData_e_sub_hm  = MyData_e_sub.drop(columns=['dataset', '51% Attack', 'happy_nonZero', \
                                                    'angry_nonZero', 'surprise_nonZero', \
                                                    'sad_nonZero', 'fear_nonZero', \
                                                    'happy_nonZero%', 'angry_nonZero%', 'surprise_nonZero%', \
                                                    'sad_nonZero%', 'fear_nonZero%', \
                                                    'happy_angry_surprise_sad_fear_allZero%_1', \
                                                    'happy_only', 'angry_only', 'surprise_only', \
                                                    'sad_only', 'fear_only', \
                                                    'happy_angry', 'happy_surprise', \
                                                    'happy_sad', 'happy_fear', \
                                                    'angry_surprise', 'angry_sad', \
                                                    'angry_fear', 'surprise_sad', \
                                                    'surprise_fear', 'sad_fear', \
                                                    'happy_angry_surprise', 'happy_angry_sad', \
                                                    'happy_angry_fear', 'happy_surprise_sad', \
                                                    'happy_surprise_fear', 'happy_sad_fear', \
                                                    'angry_surprise_sad', 'angry_surprise_fear', \
                                                    'angry_sad_fear', 'surprise_sad_fear', \
                                                    'happy_angry_surprise_sad', 'happy_angry_surprise_fear', \
                                                    'happy_surprise_sad_fear', 'angry_surprise_sad_fear', \
                                                    'happy_angry_surprise_sad_fear', \
                                                    'happy_angry_surprise_sad_fear_allZero'], axis=1)
MyData_e_sub_hm

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(20,8))

sns.heatmap(data=MyData_e_sub_hm,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Proportion\ of\ Emotion\ Volumes\ EV(A_{i})$')
plt.ylabel(r'$Events$')

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((-0.5,0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5, \
               14.5,15.5,16.5,17.5,18.5,19.5,20.5,21.5,22.5,23.5,24.5,25.5,26.5,27.5,28.5,30))
ax.set_xticklabels(('$(HV,-,-,-,-)$', '$(-,AV,-,-,-)$', '$(-,-,SV,-,-)$', '$(-,-,-,DV,-)$', \
                    '$(-,-,-,-,FV)$', '$(HV,AV,-,-,-)$', '$(HV,-,SV,-,-)$', \
                    '$(HV,-,-,DV,-)$', '$(HV,-,-,-,FV)$', '$(-,AV,SV,-,-)$', \
                    '$(-,AV,-,DV,-)$', '$(-,AV,-,-,FV)$', '$(-,-,SV,DV,-)$', \
                    '$(-,-,SV,-,FV)$', '$(-,-,-,DV,FV)$', '$(HV,AV,SV,-,-)$', \
                    '$(HV,AV,-,DV,-)$', '$(HV,AV,-,-,FV)$', '$(HV,-,SV,DV,-)$', \
                    '$(HV,-,SV,-,FV)$', '$(HV,-,-,DV,FV)$', '$(-,AV,SV,DV,-)$', \
                    '$(-,AV,SV,-,FV)$', '$(-,AV,-,DV,FV)$', '$(-,-,SV,DV,FV)$', \
                    '$(HV,AV,SV,DV,-)$', '$(HV,AV,SV,-,FV)$', '$(HV,-,SV,DV,FV)$', \
                    '$(-,AV,SV,DV,FV)$', '$(HV,AV,SV,DV,FV)$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of Emotion combinations (in %) across the subsets ", y=1.1, fontsize = 24)


# Save the figure
plt.savefig("emotion_proportion_sub.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_v_prop_sub.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)


plt.show()

MyData_b.head(2)

# drop the columns that are not needed

MyData_b_hm  = MyData_b.drop(columns=['Benchmark datasets', 'dataset', 'positive', 'neutral', \
                                      'negative', 'positive %', 'neutral %',  'negative %', \
                                      'happy', 'angry', 'surprised', 'sad', 'fear', \
                                      'happy %', 'angry %', 'surprised %', 'sad %', 'fear %', \
                                      'happy_nonZero', 'angry_nonZero', 'surprise_nonZero', \
                                      'sad_nonZero', 'fear_nonZero', 'happy_nonZero%', \
                                      'angry_nonZero%', 'surprise_nonZero%', \
                                      'sad_nonZero%', 'fear_nonZero%', \
                                      'happy_angry_surprise_sad_fear_allZero%_1', \
                                      'happy_only', 'angry_only', 'surprise_only', \
                                      'sad_only', 'fear_only', \
                                      'happy_angry', 'happy_surprise', \
                                      'happy_sad', 'happy_fear', \
                                      'angry_surprise', 'angry_sad', \
                                      'angry_fear', 'surprise_sad', \
                                      'surprise_fear', 'sad_fear', \
                                      'happy_angry_surprise', 'happy_angry_sad', \
                                      'happy_angry_fear', 'happy_surprise_sad', \
                                      'happy_surprise_fear', 'happy_sad_fear', \
                                      'angry_surprise_sad', 'angry_surprise_fear', \
                                      'angry_sad_fear', 'surprise_sad_fear', \
                                      'happy_angry_surprise_sad', 'happy_angry_surprise_fear', \
                                      'happy_surprise_sad_fear', 'angry_surprise_sad_fear', \
                                      'happy_angry_surprise_sad_fear', \
                                      'happy_angry_surprise_sad_fear_allZero'], axis=1)
MyData_b_hm

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
from matplotlib import ticker
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(20,8))

sns.heatmap(data=MyData_b_hm,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Proportion\ of\ Emotion\ Volumes\ EV(B_{i})$')
plt.ylabel("$Events$")

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((-0.5,0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5, \
               14.5,15.5,16.5,17.5,18.5,19.5,20.5,21.5,22.5,23.5,24.5,25.5,26.5,27.5,28.5,30))
ax.set_xticklabels(('$(HV,-,-,-,-)$', '$(-,AV,-,-,-)$', '$(-,-,SV,-,-)$', '$(-,-,-,DV,-)$', \
                    '$(-,-,-,-,FV)$', '$(HV,AV,-,-,-)$', '$(HV,-,SV,-,-)$', \
                    '$(HV,-,-,DV,-)$', '$(HV,-,-,-,FV)$', '$(-,AV,SV,-,-)$', \
                    '$(-,AV,-,DV,-)$', '$(-,AV,-,-,FV)$', '$(-,-,SV,DV,-)$', \
                    '$(-,-,SV,-,FV)$', '$(-,-,-,DV,FV)$', '$(HV,AV,SV,-,-)$', \
                    '$(HV,AV,-,DV,-)$', '$(HV,AV,-,-,FV)$', '$(HV,-,SV,DV,-)$', \
                    '$(HV,-,SV,-,FV)$', '$(HV,-,-,DV,FV)$', '$(-,AV,SV,DV,-)$', \
                    '$(-,AV,SV,-,FV)$', '$(-,AV,-,DV,FV)$', '$(-,-,SV,DV,FV)$', \
                    '$(HV,AV,SV,DV,-)$', '$(HV,AV,SV,-,FV)$', '$(HV,-,SV,DV,FV)$', \
                    '$(-,AV,SV,DV,FV)$', '$(HV,AV,SV,DV,FV)$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of Emotion combinations (in %) across the benchmark datasets ", y=1.1, fontsize = 24)



# Save the figure
plt.savefig("emotion_proportion_benchmark.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_v_prop_bench.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

plt.show()



"""Emotion proportions combined"""

# set 51% Attack column as index and keep the columns that are needed

MyData_e_whole_hm2  = pd.DataFrame(MyData_e_whole[['happy_nonZero%', 'angry_nonZero%', \
                                                   'surprise_nonZero%', 'sad_nonZero%', \
                                                   'fear_nonZero%', 'happy_angry_surprise_sad_fear_allZero%_1']])


MyData_e_whole_hm2 = MyData_e_whole_hm2.rename(columns={
    'happy_nonZero%': 'H($W_i$)>0',
    'angry_nonZero%': 'A($W_i$)>0',
    'surprise_nonZero%': 'S($W_i$)>0',
    'sad_nonZero%': 'D($W_i$)>0',
    'fear_nonZero%': 'F($W_i$)>0',
    'happy_angry_surprise_sad_fear_allZero%_1': '(0,0,0,0,0)'
})


MyData_e_whole_hm2

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(5,4))

sns.heatmap(data=MyData_e_whole_hm2,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Aggregated\ Emotion\ Volumes\ EV(W_{i})$')
plt.ylabel(r'$Events$')

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((0.5,1.5,2.5,3.5,4.5,5.5))
ax.set_xticklabels(('$H(W_{i})>0$', '$A(W_{i})>0$', '$S(W_{i})>0$', \
                    '$D(W_{i})>0$', '$F(W_{i})>0$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of combined Emotion combinations (in %) across the whole datasets ", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("emotion_proportion_whole2.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_proportion_whole2.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)
plt.show()

# set 51% Attack column as index and keep the columns that are needed

MyData_e_sub_hm2  = pd.DataFrame(MyData_e_sub[['happy_nonZero%', 'angry_nonZero%', \
                                                   'surprise_nonZero%', 'sad_nonZero%', \
                                                   'fear_nonZero%', 'happy_angry_surprise_sad_fear_allZero%_1']])
MyData_e_sub_hm2

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(5,4))

sns.heatmap(data=MyData_e_sub_hm2,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Aggregated\ Emotion\ Volumes\ EV(A_{i})$')
plt.ylabel(r'$Events$')

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((0.5,1.5,2.5,3.5,4.5,5.5))
ax.set_xticklabels(('$H(W_{i})>0$', '$A(W_{i})>0$', '$S(W_{i})>0$', \
                    '$D(W_{i})>0$', '$F(W_{i})>0$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of combined Emotion combinations (in %) across the subsets ", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("emotion_proportion_sub2.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_proportion_sub2.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)
plt.show()



# keep the columns that are needed

MyData_b_hm2  = pd.DataFrame(MyData_b[['happy_nonZero%', 'angry_nonZero%', \
                                                   'surprise_nonZero%', 'sad_nonZero%', \
                                                   'fear_nonZero%', 'happy_angry_surprise_sad_fear_allZero%_1']])
MyData_b_hm2

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
from matplotlib import ticker

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(5,4))

sns.heatmap(data=MyData_b_hm2,
            annot=False,
            linewidths=0.5,
            cbar=True,
            center=50)

# Get the colorbar from the Axes object
cbar = ax.collections[0].colorbar

# Change the colorbar labels to LaTeX font
cbar.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('$%s$'))

# Add a title to the colorbar
cbar.set_label('$Values\ (in\ \%)$', rotation=270, labelpad=20)

plt.xlabel(r'$Aggregated\ Emotion\ Volumes\ EV(B_{i})$')
plt.ylabel(r'$Events$')

ax.set_yticks((0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5))
ax.set_yticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'), rotation=0)

ax.set_xticks((0.5,1.5,2.5,3.5,4.5,5.5))
ax.set_xticklabels(('$H(W_{i})>0$', '$A(W_{i})>0$', '$S(W_{i})>0$', \
                    '$D(W_{i})>0$', '$F(W_{i})>0$', '$(0,0,0,0,0)$'), rotation=60)

# Add a title
#plt.title("Proportion of combined Emotion combinations (in %) across the benchmark datasets ", y=1.1, fontsize = 24)

# Save the figure
plt.savefig("emotion_proportion_benchmark2.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("emotion_proportion_benchmark2.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

plt.show()



"""### Emotions line graphs"""

import pandas as pd
df = pd.read_csv('happy.csv')
df_a = pd.read_csv('angry.csv')
df_s = pd.read_csv('surprised.csv')
df_d = pd.read_csv('sad.csv')
df_f = pd.read_csv('fear.csv')
df.head()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX with 1 decimal place
def format_func(value, tick_number):
    return r'$%.1f$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,4))

# Plot the data
df.plot(kind='line',
        figsize=(12, 6),
        use_index=True,
        colormap='Set1',
        ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Events$')
plt.ylabel(r'$Mean\ values\ of\ happy\ emotions\ [0,1]$')

ax.set_xticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_xticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the y-axis
ax.yaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$W_{i}$', r'$A_{i}$', r'$B_{i}$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("Happy.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("happy.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX with 1 decimal place
def format_func(value, tick_number):
    return r'$%.1f$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,4))

# Plot the data
df_a.plot(kind='line',
        figsize=(12, 6),
        use_index=True,
        colormap='Set1',
        ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Events$')
plt.ylabel(r'$Mean\ values\ of\ angry\ emotions\ [0,1]$')

ax.set_xticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_xticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the y-axis
ax.yaxis.set_major_formatter(formatter)

# Apply the formatter to the legend labels
plt.legend([r'$W_{i}$', r'$A_{i}$', r'$B_{i}$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("Angry.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("angry.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX with 1 decimal place
def format_func(value, tick_number):
    return r'$%.1f$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,4))

# Plot the data
df_s.plot(kind='line',
        figsize=(12, 6),
        use_index=True,
        colormap='Set1',
        ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Events$')
plt.ylabel(r'$Mean\ values\ of\ surprised\ emotions\ [0,1]$')

ax.set_xticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_xticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the y-axis
ax.yaxis.set_major_formatter(formatter)

# Set the y-axis limits and ticks
ax.set_ylim(0, 0.4)
ax.set_yticks([i/10.0 for i in range(5)])

# Apply the formatter to the legend labels
plt.legend([r'$W_{i}$', r'$A_{i}$', r'$B_{i}$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("Surprised.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("surprised.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX with 1 decimal place
def format_func(value, tick_number):
    return r'$%.1f$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,4))

# Plot the data
df_d.plot(kind='line',
        figsize=(12, 6),
        use_index=True,
        colormap='Set1',
        ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Events$')
plt.ylabel(r'$Mean\ values\ of\ sad\ emotions\ [0,1]$')

ax.set_xticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_xticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the y-axis
ax.yaxis.set_major_formatter(formatter)

# Set the y-axis limits and ticks
ax.set_ylim(0, 0.6)
ax.set_yticks([i/10.0 for i in range(7)])

# Apply the formatter to the legend labels
plt.legend([r'$W_{i}$', r'$A_{i}$', r'$B_{i}$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("Sad.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("sad.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

# Define a function to format the numbers using LaTeX with 1 decimal place
def format_func(value, tick_number):
    return r'$%.1f$' % value

# Create a formatter
formatter = FuncFormatter(format_func)

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,4))

# Plot the data
df_f.plot(kind='line',
        figsize=(12, 6),
        use_index=True,
        colormap='Set1',
        ax=ax)

plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)
plt.xlabel(r'$Events$')
plt.ylabel(r'$Mean\ values\ of\ fear\ emotions\ [0,1]$')

ax.set_xticks((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))
ax.set_xticklabels(('$E_1$', '$E_2$', '$E_3$', '$E_4$','$E_5$','$E_6$', '$E_7$', \
                    '$E_8$', '$E_9$', '$E_{10}$', '$E_{11}$', '$E_{12}$', \
                    '$E_{13}$', '$E_{14}$', '$E_{15}$', '$E_{16}$', '$E_{17}$'))

# Apply the formatter to the y-axis
ax.yaxis.set_major_formatter(formatter)

# Set the y-axis limits and ticks
ax.set_ylim(0, 0.9)
ax.set_yticks([i/10.0 for i in range(10)])

# Apply the formatter to the legend labels
plt.legend([r'$W_{i}$', r'$A_{i}$', r'$B_{i}$'], bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("Fear.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("fear.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()



"""### Peak days"""

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import matplotlib as mpl
from matplotlib.ticker import FuncFormatter
from matplotlib.path import Path
from matplotlib.transforms import Affine2D

# Use LaTeX-style font
mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'

sns.set_theme(style="white", context="talk")

#Create an ellipse path by scaling a unit circle
ellipse = Path.unit_circle()
ellipse = ellipse.transformed(Affine2D().scale(2.2, 1.2))

#Define the y-axis tick labels
y_labels = ["$day\ 0*$", "$day\ 1$", "$day\ 2$", "$day\ 3$", "$day\ 4$", "$day\ 5$", "$day\ 6$", "$day\ 7$"]


#Define the x-axis tick labels
x_labels = ["$2013\ /\ II\ $", "$2013\ /\ III$", "$2013\ /\ IV\ $", "$2014\ /\ I\t\t$", "$2014\ /\ II\ $", \
            "$...\ $", "$2018\ /\ I\t\t$", "$2018\ /\ II\ $", "$2018\ /\ III$", "$2018\ /\ IV\ $", \
            "$2019\ /\ I\ \ $", "$2019\ /\ II\ $", "$2019\ /\ III$", "$2019\ /\ IV\ $", "$2020\ /\ I\ \ $", \
            "$2020\ /\ II\ $", "$2020\ /\ III$", "$2020\ /\ IV\ $", "$2021\ /\ I\ \ $", "$2021\ /\ II\ $", \
            "$2021\ /\ III$", "$2021\ /\ IV\ $"]

# Define the color codes and labels for the spots
colors = ["black", "darkgrey", "lightgreen", "darkorange", "lightblue", "gold", "purple", "fuchsia"]
labels = ["$FTC$", "$BTC$", "$BTG$", "$LTC$", "$XVG$", "$VTC$", "$ETC$", "$BSV$" ]

# Define the positions of the spots
positions = [(2, 0), (0, 4), [(6.2, 3, 1.2), (6.9, 14, 15.8)], [(5.9, 4), (7.1, 12)], \
             [(1.2,0.9),(6.9,7.1)], [(2,1),(9,13)], [(0.3,0,1,0.8),(12,16,16,16.2)], \
             [(2,1),(19.9,20.1)]]

#Create a figure and an axes object
fig, ax = plt.subplots(figsize=(12,4))

# Add the guided lines
for y in range(len(y_labels)):
    ax.axhline(y, xmin=0, xmax=len(x_labels), color='lightgrey', linestyle='--', linewidth=0.5)
for x in range(len(x_labels)):
  ax.axvline(x, ymin=0, ymax=len(y_labels), color='lightgrey', linestyle='--', linewidth=0.4)


#Plot the spots with color, label and position
for i in range(len(colors)):
  ax.scatter(positions[i][1], positions[i][0], color=colors[i], label=labels[i],  marker=ellipse, s=500)

# Add a textbox
#props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
#ax.text(0.05, 0.05, "* this means this.", fontsize=8, transform=ax.transAxes, bbox=props)
# Add a textbox outside the figure, under the x-axis label
fig.text(0.1, -0.25, "$*\ day\ 0\ =\ day\ of\ the\ attack\ or\ last\ day\ of\ the\ attack$", fontsize=10, ha='left', va='bottom', transform=fig.transFigure)

#Set the y-axis ticks and labels
ax.set_yticks(range(len(y_labels)))
ax.set_yticklabels(y_labels, fontsize=14)

#Set the x-axis ticks and labels
#ax.set_xticks(range(len(x_labels)))
ax.set_xticks((-0.4,0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6,9.6,10.6,11.6,12.6,13.6,14.6,15.6,16.6,17.6,18.6,19.6,20.6))
ax.set_xticklabels(x_labels, fontsize=14, rotation=60)

plt.ylabel(r'$Peak\ days\ of\ setiments$')
plt.xlabel(r'$Timeline\ of\ events\ (quarter\ of\ years)$')

#Add a legend
ax.legend(fontsize=14, bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("PeakDays.png",
            bbox_inches="tight",
            dpi=200)

# Save the figure
plt.savefig("PeakDays.eps",
            format='eps',
            bbox_inches="tight",
            dpi=200)


#Show the plot
plt.show()



"""### Compound scores with/without the word attack"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

MyData = pd.read_csv('Dataset_sub_bitcoingold_15_05_2018.csv')
MyData.head()

# Visualise the result

# Import packages
import matplotlib.pyplot as plt
import seaborn as sns

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,8))

# Use histplot
sns.histplot(x="sentiment_score",
             data=MyData,
             # kernal density estimation
             kde=True,
             # control the bin width
             binwidth=0.02
             )

# Add label to horiztontal axis
ax.set_xlabel("Compound Score")

# Remove ylabel
ax.set_ylabel("Frequency")

# Add a title
ax.set_title("Sentiment Distribution for Bitcoin Gold 51% attack [16-19 May 2018] subset with the word 'attack'", fontsize = 18)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("sentDist1.png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

import re
MyData2 = MyData
#Remove the word 'attack'
MyData2['clean_content'] = MyData2['clean_content'].str.replace(r"attack", "")


MyData2.head()

# Import the library for sentiment analysis

import nltk
nltk.download('vader_lexicon')
from nltk.sentiment.vader import SentimentIntensityAnalyzer
sia = SentimentIntensityAnalyzer()

# Define some functions for convenience

def getSentScore(text):
  myScore = sia.polarity_scores(text)['compound']
  return(myScore)

# Generate a new column to store the compound scores

MyData2['sentiment_score2'] = MyData2.apply(lambda x: getSentScore(x['clean_content']), axis=1)

# Visualise the result

# Import packages
import matplotlib.pyplot as plt
import seaborn as sns

# Set a more specific style
sns.set_theme(style="white", context="talk")

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(12,8))

# Use histplot
sns.histplot(x="sentiment_score2",
             data=MyData2,
             # kernal density estimation
             kde=True,
             # control the bin width
             binwidth=0.02
             )

# Add label to horiztontal axis
ax.set_xlabel("Compound Score")

# Remove ylabel
ax.set_ylabel("Frequency")

# Add a title
ax.set_title("Sentiment Distribution for Bitcoin Gold 51% attack [16-19 May 2018] subset without the word 'attack'", fontsize = 18)

# Remove the border line
sns.despine(left=True, bottom=True)

# Save the figure
plt.savefig("sentDist2.png",
            bbox_inches="tight",
            dpi=200)

# Show nicely in the notebook
plt.show()

